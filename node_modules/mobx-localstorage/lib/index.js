'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('mobx'),
    ObservableMap = _require.ObservableMap,
    toJS = _require.toJS;

var ENV = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : undefined;

if (!ENV) {
  throw new Error('unknown environment');
}

if ('localStorage' in ENV) {
  module.exports = asLocalStorage();
} else {
  console.error('You environment doesn\'t support localStorage'); // eslint-disable-line no-console
}

function asLocalStorage() {
  listen(function (_ref) {
    var key = _ref.key,
        newValue = _ref.newValue,
        oldValue = _ref.oldValue;

    feed(key, newValue, oldValue);
  });

  var store = new ObservableMap(cloneLocalStorage());

  var LocalStorage = function () {
    function LocalStorage() {
      _classCallCheck(this, LocalStorage);
    }

    _createClass(LocalStorage, [{
      key: 'getItem',
      value: function getItem(key) {
        return this.get(key);
      }
    }, {
      key: 'setItem',
      value: function setItem(key, value) {
        return this.set(key, value);
      }
    }, {
      key: 'removeItem',
      value: function removeItem(key) {
        return this.delete(key);
      }
    }, {
      key: 'clear',
      value: function clear() {
        localStorage.clear();
        store.clear();
      }
    }, {
      key: 'has',
      value: function has(key) {
        return store.has(key);
      }
    }, {
      key: 'get',
      value: function get(key) {
        return store.get(key);
      }
    }, {
      key: 'set',
      value: function set(key, value) {
        var json = JSON.stringify(toJS(value));
        localStorage.setItem(key, json);
        store.set(key, value);
      }
    }, {
      key: 'delete',
      value: function _delete(key) {
        localStorage.removeItem(key);
        store.delete(key);
      }
    }, {
      key: 'keys',
      value: function keys() {
        return store.keys();
      }
    }, {
      key: 'values',
      value: function values() {
        return store.values();
      }
    }, {
      key: 'entries',
      value: function entries() {
        return store.entries();
      }
    }, {
      key: 'forEach',
      value: function forEach() {
        return store.forEach.apply(store, arguments);
      }
    }, {
      key: 'length',
      get: function get() {
        return localStorage.length;
      }
    }, {
      key: 'size',
      get: function get() {
        return store.size;
      }
    }]);

    return LocalStorage;
  }();

  return new LocalStorage();

  function feed(key, newValue, oldValue) {
    if (newValue === null) {
      if (oldValue === null) {
        console.warn('localStorage: unexpected event type'); // eslint-disable-line no-console
      } else {
        store.delete(key);
      }
    } else {
      store.set(key, parseValue(newValue));
    }
  }
}

function listen(cb) {
  if (ENV.addEventListener) {
    ENV.addEventListener('storage', cb, true);
  } else if (ENV.attachEvent) {
    ENV.attachEvent('storage', cb);
  } else {
    console.error('You environment doesn\'t support event listener'); // eslint-disable-line no-console
  }
}

function cloneLocalStorage() {
  var state = {};
  var len = localStorage.length;
  for (var i = 0; i < len; i++) {
    var key = localStorage.key(i);
    state[key] = parseValue(localStorage.getItem(key));
  }
  return state;
}

function parseValue(value) {
  try {
    return JSON.parse(value);
  } catch (e) {
    // ignore if cannot parse as JSON
  }
  return value;
}